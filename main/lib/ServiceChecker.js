// Generated by CoffeeScript 1.10.0

/*
 * service-checker
 * Author: MrKMG (https://github.com/mrkmg)
 *
 * MIT License
 */

(function() {
  var CheckResult, DuplicateProviderError, Promise, PromiseWhile, ServiceChecker, _, allowed_properties, defaults;

  _ = require('underscore');

  Promise = require('bluebird');

  PromiseWhile = (require('./components/PromiseWhile'))(Promise);

  CheckResult = require('./components/CheckResult');

  DuplicateProviderError = require('./errors/DuplicateProviderError');

  allowed_properties = ['timeout', 'ca', 'retries'];

  defaults = {
    timeout: 5000,
    retries: 0,
    ca: null
  };

  ServiceChecker = (function() {
    function ServiceChecker(options) {
      var invalid_properties;
      if (!_.isObject(options)) {
        options = {};
      }
      _.defaults(options, defaults);
      if (!_.isNumber(options.timeout)) {
        throw new Error('Timeout must be a number');
      }
      if (!_.isNumber(options.retries)) {
        throw new Error('Retries must be a number');
      }
      if ((!_.isArray(options.ca)) && (!_.isString(options.ca)) && (!_.isNull(options.ca))) {
        throw new Error('CA must be an array, string, or empty');
      }
      invalid_properties = _.chain(options).omit(allowed_properties).keys().value();
      if (invalid_properties.length > 0) {
        throw new Error('Unknown Properties: ' + invalid_properties.join(', '));
      }
      this._options = options;
    }

    ServiceChecker.prototype._makeHandler = function(name, handler) {
      this[name] = function(options, callback) {
        return this._runHandler(name, handler, options, callback);
      };
      return this._loaded.push(name);
    };

    ServiceChecker.prototype._runHandler = function(name, handler, options, callback) {
      var check_result, default_options, result;
      if (options === void 0) {
        options = {};
      }
      default_options = this._options;
      result = void 0;
      check_result = Promise["try"](function() {
        result = new CheckResult(name);
        return _.defaults(options, default_options);
      }).then(function(options) {
        var last_result, run, run_count, test;
        run_count = 0;
        last_result = void 0;
        test = function() {
          return (++run_count <= options.retries) && !!last_result;
        };
        run = function() {
          return Promise.resolve(options).then(handler).then(function(result) {
            return last_result = result;
          });
        };
        return PromiseWhile(test, run).then(function() {
          return last_result;
        });
      }).then(function(error) {
        return result.finished(error);
      });
      if (_.isFunction(callback)) {
        check_result.then(function(result) {
          return callback(null, result);
        })["catch"](function(error) {
          return callback(error);
        });
      }
      return check_result;
    };

    ServiceChecker.prototype.use = function(plugin) {
      var self;
      self = this;
      if (!_.isObject(plugin)) {
        throw new Error('plugin must key:value object');
      }
      _.each(plugin, function(handler, name) {
        if (self.hasOwnProperty(name)) {
          throw new DuplicateProviderError(name);
        }
      });
      _.each(plugin, function(handler, name) {
        if (_.isFunction(handler) && _.isString(name)) {
          return self._makeHandler(name, handler);
        } else {
          throw new Error(name + " does not have a valid handler");
        }
      });
      return this;
    };

    ServiceChecker.prototype._options = {};

    ServiceChecker.prototype._name = 'service-checker';

    ServiceChecker.prototype._loaded = [];

    module.exports = function(options) {
      return new ServiceChecker(options);
    };

    return ServiceChecker;

  })();

}).call(this);
